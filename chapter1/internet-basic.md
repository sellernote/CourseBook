# 인터넷 기본
인터넷이란 광활한 통신망을 통해 세계 어디에 있어도 교류가 가능하고, 개발에 있어 매우 밀접한 관계를 가지기 때문에 이론적으로 어느정도 알아야하는 토픽이라고 생각한다! 전문가는 아니지만, 검색을 통해 정리한 개념들이다. 

## 인터넷이란
인터넷이란 말의 유래는 여러 통신망을 하나로 연결한다는 의미의 '인터 네트워크' (inter-network)라는 말에서 시작되었고, 이제는 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다. 클라이언트와 서버로 이루어져있는 인터넷은 TCP/IP 프로토콜을 기반으로 한 전 세계의 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망이다. 수많은 클라이언트와 서버 컴퓨터로 이루어진 네트워크들의 집합체라고도 볼 수 있다.

### 특징
- 유닉스 운영체제를 기반으로 한다. 
- 동시에 참여할 수 있는 쌍방향 통신을 제공한다: 통신망과 컴퓨터만 있다면 시간과 장소를 떠나 정보를 교환할 수 있다. 
- 인터넷에 연결된 모든 컴퓨터는 고유한 IP를 가지고 있다. 
- 연결을 위해서는 브리지, 라우터, 게이트웨이가 사용된다. 

### 서비스
- **WWW (World Wide Web)**: 텍스트, 그림, 동영상과 음성 같은 다양한 정보를 제공하는 종합 정보서비스이면 HTTP 프로토콜을 사용하는 하이퍼텍스트 기반으로 되어 있다. WWW의 효과적인 검색을 도와주는 프로그램을 웹 브라우저라고 한다. 
- **전자우편(E-Mail)**: 인터넷을 통해 다른 사람과 다양한 형식의 데이터를 주고 받을 수 있게 해주는 서비스로 SMTP, POP3, MIME 프로토콜을 사용한다. 
- **텔넷(Telnet)**: 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스. 시스템 관리 작업을 가능케 하는 가상의 터미널 기능을 수행한다. 
- **HTTP(Hyper Text Transfer Protocol)**: 하이퍼 텍스트 문서 전송을 위한 프로토콜. 
- **FTP(File Transfer Protocol)**: 파일 전송 프로토콜은 말 그래도 컴퓨터와 컴퓨터, 컴퓨터와 인터넷 사이에서 파일을 주고 받을 수 있도록 해주는 원격 파일 전송 프로토콜 이다. 
- **아키(Archie)**: 익명의 FTP 사이트에 있는 FTP 서버와 그 안의 파일 정보를 데이터베이스에 저장해 두었다가 FTP 서버의 리스트와 파일을 제공해 정보를 쉽게 검색할 수 있도록 하는 서비스이다. 
- **고퍼(Gopher)**: 메뉴 방식을 이용해 정보 검색을 할 수 있게 해주는 서비스
- **유즈넷(USENET)**: 분야별로 분리되어 있는 네트워크. 유저 네트워크의 준말이다. 

### Conclusion
1960년대 알파넷 (ARPANET)에서 시작된 인터넷은 현재 사람들에게 없어서는 안될 네트워크 집합체로 서로 정보를 교환하고 정보 획득을 가능케하는 역할을 한다. 데이터의 전송 속도는 더욱 빨라지고 안정적으로 발전되고 있다. 이러한 인터넷이 서로를 연결시켜주고 온라인 서비스를 가능케 하기에 삶이 더욱 편안해졌다고 할 수 있다. 접하는 정보의 양과 질이 더욱 향상되었다. 

**출처**
- https://coding-factory.tistory.com/344
- http://tcpschool.com/webbasic/intro


## HTTP

### Introduction
- **Hyper Text Transfer Protocol**, 즉 HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토 콜로, 웹에서 이루어지는 모든 데이터 교환의 기초이며 클라이언트와 서버 사이의 프로토콜이기도 하다. 프로토콜은 두 컴퓨터 간의 통신을 위한 규칙의 집합이고, HTTP는 문자로 된 독립적인 프로토콜이다. 

### 특징
- **Textual**: 모든 명령어들은 기본 문자이며 사람들이 읽을 수 있다. 
- **Stateless**: 서버 혹은 클라이언트는 이전의 통신을 기억하지 않는다. 그래서 HTTP만 사용하면 서버는 전에 입력한 비밀번호 나 어디까지 처리했는지 기억하지 못한다. 그런일을 위해선 애플리케이션 서버가 필요하다. 
- 클라이언트만이 HTTP 요청을 만들어 서버에게 보낼 수 있고, 서버는 오직 클라이언트의 요청에만 응답이 가능하다. 
- HTTP를 통해 파일을 요청할 때 클라이언트는 반드시 URL 파일을 제공해야 한다. 
- 웹 서버는 최소한 에러 메시지를 포함해 모든 HTTP 요청에 응답해야 한다. 
	- 클라이언트의 요청 => HTTP 서버가 요청받은 URL이 있는 파일과 매칭이 되는지 확인 => 매칭되면 브라우저에 리턴, 아니면 애플리케이션 파일은 필요한 파일을 구축 => 만약 불가능할 경우, 에러메시지 반환 ("404 Not Found") 

### HTTP Process
**브라우저에 URL을 입력하고 요청한 페이지까지 무슨일이 일어날까? 간략하게 정리해보았다. (요약한 부분들이 있다...! 완전 세세한 디테일까지 알고 싶다면 아래 기재할 출처를 들어가서 확인...!) ** 

1. 먼저, 웹 브라우저가 URL을 문법에 따라 해석한다.
2. 만약 이 URL이 문법에 맞지 않는다면, 입력을 웹 브라우저의 기본 검색 엔진으로 검색 요청을 한다.

3. URL문법이 맞다면, Punycode (퓨니코드)(유니코드 문자열을 호스트 이름에서 허용된 문자만 인코딩 하는 방법)endoding을 url의 host부분에 적용한다.

4. HSTS(HTTP Strict Transport Security)목록을 로드해서 확인한다.
- 	HSTS목록에 있으면 첫 요청을 HTTPS로 보내고, 아닌 경우 HTTP로 보낸다.
**(HTTP Strict Transport Security: HTTP대신 HTTPS만을 사용하여 통신해야 한다고 웹 사이트가 웹 브라우저에 알리는 보안기능)**

5. DNS(Domain Name Server) 조회한다.
1) 도메인이 cache 이 있는지, 없으면 로컬에 있는지도 확인. 
2) 실패 시 Network stack에 구성 돼 있는 DNS로 요청을 보낸다. (DNS는 일반적으로 Local router, ISP의 캐싱 DNS)

6. ARP(Address Resolution Protocol)로 대상의 IP와 MAC address를 알아낸다.

7. 대상과 TCP 통신을 통해 Socket을 연다.
- 	브라우저가 서버의 IP 를 받으면 포트를 가져와서 TCP 소켓 스트림 요청. 소켓 내에서 통신이 이루어짐. 

8. HTTPS 인 경우 TLS(Transport layer Security) Handshake 가 추가된다. 
- 	TLS 는 SSL(Secure Sockets Layer)의 표준화 된 이름이다. 
- 	TCP 소켓 통신에 추가

9. HTTP 라면 HTTP 프로토콜로 요청한다. 7번 직후. HTTPS 라면 8번의 소켓 통신 이후이다. 

10. HTTP 서버가 응답한다. (HTTP daemon) 
- 	HTTPD 서버가 요청 / 응답을 처리한다. (Linux는 Apache 아니면 Nginx, Windows의 경우 IIS)

11. 제공받은 데이터로 웹 브라우저가 렌더된다. 

### HTTP Request and Header
HTTP 요청 그 자체에 대한 정보를 담고 있다. key:value로 이루어져있다. (서버 응답의 경우 Server-Header)
- Host : 요청이 전송되는 target의 호스트 URL주소
- User-Agent : 요청을 보내는 클라이언트 정보
- Accept : 해당 요청이 받을 수 있는 응답, body데이터 타입의 정보(모든 타입을 허용하는 경우 '*/* '로 지정
  (MIME type) Multipurpost Internet Mail Extensions (ex. application/json)
- **Connection**
   - 해당 요청이 끝난 후에 클라이언트와 서버 간의 연결을 계속 유지할 것인지 알려주는 헤더
    - HTTP 요청마다 네트워크 연결을 새로 만드는 건 번거롭기 때문에 요청이 계속되는 한 처음 연결을 재사용 하는 것이 바람직하다. 
    - keep - alive : 네트워크 연결을 유지해라
    - close : 더이상 요청을 보내지 않으니 연결을 닫아라
- **Content - type**
    - HTTP요청이 보내는 메세지 body타입을 알려준다.
    - MIME type
- **Content-Length** : 요청이 보내는 메시지 body의 총 사이즈 정보

### HTTP vs HTTPS
- 텍스트 기반의 정보통신을 하는 HTTP의 보안의 취약성을 보완하기 위한것이 HTTPS이다. S는 Secure Socket을 의미하며, 데이터를 주고 받는 과정에서 보안 요소가 추가된다. 클라이언트와 서버키가 각각 공개키와 비밀키(개인키)를 갖고 암호화를 한 정보를 전송하기 때문에 키의 사용자만 이 정보를 볼 수 있다.
- 보안 요소가 추가되기 때문에 HTTP의 보안 취약점을 보완해주지만, 웹 서버에 접속하는 사용자마다 다른 암호를 제공해야 하기에 쉽지 않고 비싸다. 
- 과거에는 웹서버에 부하를 준다고 https 를 적용하지 않았다. 네이버나 다음도 https 적용한지 그리 오래되지 않았다는 사실...! (CTO님 소스)

#### Why HTTPS?
- HTTPS는 보안 기능이 추가되어 처리 속도가 더 느리고 관련 웹서버의 사양도 중요한 부분이다. 
- 가벼운 웹서핑 같이 가벼운 데이터만 처리한다면 HTTP를 사용할 수 있겠지만 자료를 주고 받고 중요한 정보를 처리한다면 정보 유출을 막기 위해 HTTPS 사용이 필수이다. 
- 사용자가 키워드 검색 시 상위 노츨되는 기준 중 하나가 보안 요소이기에 HTTPS 사이트가 HTTP 사이트보다 우선 검색될 수 있고, 또 보안이 보장 되어 있다는 장점이 있기에 더 많은 사용자를 유혹할 수 있다. 

### HTTP Response Code
- HTTP응답 코드는 5개의 클래로 분류되는데, 상태 코드의 첫번째 숫자는 응답클래스를 정의한다. 대표적으로 많이 사용하는 응답코드로는 200번대 성공 응답코드와, 400번대 클라이언트 오류, 500번대 서버오류를 뽑을 수 있다.
![](https://images.velog.io/images/rlcjf0014/post/cc7be372-f349-4a65-83bc-d794f52449a7/image.png)

### Conclusion
- HTTP에 관해 간략히 알아보았는데, 어느정도 이론을 갖추고 개발을 하면 도움이 되는 것 같다. 실제로 더 심화된 개발로 넘어가기 시작하면 면접에서도 물어보고 고려해야 할 부분들이 있기에 알아두는 것이 좋다. 

**출처**
- https://owlgwang.tistory.com/1
- https://ychae-leah.tistory.com/82
- https://post.naver.com/viewer/postView.nhn?volumeNo=16561296&memberNo=1834
- https://ko.wikipedia.org/wiki/HTTP_상태_코드
- https://tzamtzis.gr/2017/digital-analytics/http-status-codes/
- https://joshua1988.github.io/web-development/http-part1/
- https://developer.mozilla.org/ko/docs/Web/HTTP/Overview

## Cookie

![](https://images.velog.io/images/rlcjf0014/post/48bf8443-8e7e-4c4e-9a62-20ed3e7752c7/image.png)<br/>
**쿠키와 세션은 출처가 같이 정리되어 있습니다.**

### Introduction
쿠키와 세션이 무엇인지 본격적으로 탐구해보기 전, 먼저 이러한 것들이 왜 필요한지 아는 것이 매우 중요하다. 쿠키와 세션은 HTTP 프로토콜을 사용할 때 나타나는 약점을 보완하기 위해 사용하는 것인데 가장 흔히 쓰이는 때가 로그인 시 발급되는 토큰 및 자잘한 정보를 저장하기 위해서이다.

### HTTP 프로토콜
저번 내용에서 커버한 HTTP 프로토콜은 크게 두 가지 특징을 가지고 있다. HTTP 프로토콜은 비연결을 지향하고 (connectionless), 상태 정보를 유지하지 않는다 (Stateless). 
**비연결지향 (Connectionless)**
HTTP에서는 클라이언트가 서버에 요청을 보내면, 서버는 클라이언트에 요청에 맞는 response를 보내고 접속을 끊는 특성이 있다. 헤더에서 keep-alive 라는 값을 통해 기존의 연결을 재활용하는데 이렇게 요청이 계속 발생할 때마다 연결을 계속 유지하지 않고 있어 서버의 자원을 아낄 수 있는 장점이 있다. 
**상태정보 유지하지 않음 (Stateless)**
클라이언트와 서버가 각자 맡은 역할을 완수하고 나면 연결이 끊어지고 자연스레 통신이 끝난다. HTTP는 상태 정보를 유지하지 않기에 또 서버의 자원을 아낄 수 있다. 그렇게 사용자 정보를 따로 저장하는 수단이 없기에 항상 요청을 보낼 때마다 새로운 사용자로 인식하고 항상 로그인을 하게 만든다. 항상 요청을 보낼 때마다 로그인을 하고, 사이트에 접속할 때마다 로그인을 해야 한다면 상당히 불편하고 비효율적인 서비스 일 것이다. 물론 통신 연결을 유지하지 않기에 서버 리소스 낭비가 줄어들지만...항상 로그인 하는 것은 상상만 해도 불편하다. 
이러한 HTTP 의 특성들을 보완하고자 사용하는 기능이 쿠키와 세션이다. 

### Cookie 란?
쿠키는 클라이언트 로컬에 저장되는 데이터 파일인데 브라우저 별로 저장되는 위치가 다르다. 적절한 코딩을 통해 로컬에 저장되어 있는 클라이언트의 상태 정보를 참조할 수 있다. 세션 별로 쿠키를 설정해 줄 수 있고, 브라우저 종료 후 쿠키를 유지 하고 싶다면 Permanent 옵션을 이용하면 된다 (Expires / Max-Age 옵션). 

### 특징
- 클라이언트에 300개까지 쿠키 저장이 가능하고 하나의 도메인당 20개의 값을 가질 수 있다. 쿠키 값이 20개를 초과하면 가장 적게 사용된 쿠키부터 지워진다. 
- 하나의 쿠키값은 4KB까지 저장한다. 
- Response 헤더에 속성을 사용해 클라이언트에 쿠키를 만들 수 있고, 이후 사용자가 따로 요청하지 않아도 브라우저가 Request시에 헤더에 넣어서 자동으로 서버에 전송한다.
- 쿠키는 다음으로 구성되어 있다. 이름, 값, 유효시간, 도메인, 그리고 경로이다. 
- 일정시간 동안 데이터를 저장할 수 있다. 

### 목적
- **세션관리**: 웹 페이지를 열어 서비스를 사용하는 그 세션에서 서버가 알아야할 정보들을 저장한다. 
- **개인화**: 사용자에 따라 적절한 페이지를 개인마다 다른 저장된 정보로 꾸며 보여줄 수 있다. 
- **트래킹**: 사용자의 행동과 패턴을 분석하고 기록한다. 

### Cookie Process
1. 클라이언트가 페이지 요청
2. 서버에서 쿠키를 생성해 Response 헤더에 포함시켜 응답
3. 클라이언트에서 쿠키를 받아 보관. 브라우저 종료시 가지고 있을 지 결정 필요. 
4. 같은 요청일 경우 Request 헤더에 쿠키를 함께 보내 사용자 보증 및 필요 정보 첨부.
5. 서버에서 쿠키를 읽어 상태 정보를 변경할 필요가 있을 때 쿠키 업데이트 후 헤더에 포함해 다시 보내준다. 

위 단계들이 실제로 진행되는 단계이다. 여러 페이지를 이동해도 사용자 정보를 가지고 있고 지속적으로 로그인이 된 것 처럼 정보를 가지고 활용한다. 

## Session
**쿠키의 내용과 이어져 있습니다.**

### Introduction
쿠키와 세션이 무엇인지 본격적으로 탐구해보기 전, 먼저 이러한 것들이 왜 필요한지 아는 것이 매우 중요하다. 쿠키와 세션은 HTTP 프로토콜을 사용할 때 나타나는 약점을 보완하기 위해 사용하는 것인데 가장 흔히 쓰이는 때가 로그인 시 발급되는 토큰 및 자잘한 정보를 저장하기 위해서이다.

### Session 이란?
세션은 일정 시간동안 같은 브라우저로부터 들어오는 일련의 요구를 하나의 상태로 보고 유지하는 기술이다. 쿠키가 클라이언트에 저장되는 데이터라면 세션은 서버에 저장되는 데이터라고 할 수 있다. 

### 특징
- 서버에서는 클라이언트 구분을 위해 각각 세션 ID를 주고 브라우저 종료 전까지 인증 상태를 유지한다. 
- 접속 시간에 제한을 두어 일정 시간동안 응답이 없으면 정보가 유지되지 않도록 설정도 가능하다. 
- 사용자 정보를 서버에 두어 쿠키보다 보안이 더 훌륭하다 볼 수 있지만 사용자가 많아질수록 서버 메모리를 더 많이 차지하고, 동시 접속자가 많을 경우 서버에 과부하를 줘 성능 저하를 일으킬 수 있다. 

### Session Process
1. 클라이언트가 서버를 처음 접속할 때 세션 ID를 발급받는다. 
2. 클라이언트는 세션 ID를 쿠키를 통해 저장하고 있는다. 
3. 클라이언트는 헤더에 세션 ID를 가지고 요청을 보내고 서버는 그 아이디로 세션에 있는 정보를 가져온다. 
4. 적절한 작업 후 정보를 클라이언트에 보내준다. 
5. 브라우저가 켜져 있는 동안이 한 세션이다. 클라이언트 (브라우저) 종료 시 클라이언트의 세션 ID와 서버의 세션도 사라진다. 

쿠키보다 한 단계의 보안 필터를 넣어주는 개념이다. 

## Cookie vs Session
쿠키와 세션은 비슷한 듯 보이지만 차이가 있다. 

**저장위치**: 쿠키는 클라이언트에, 세션은 서버에 데이터를 저장한다. 
**보안**: 쿠키는 로컬에 저장되기에 변질 혹은 요청에서 스나이핑으로 정보를 빼앗길 우려가 있지만 세션은 로컬에 세션 아이디만 저장하고 실제 데이터는 다 서버에 있기에 쿠키보다는 세션이 더 보안성에서 유리하다. 하지만 누가 세션 아이디를 훔친다면...세션 정보도 도둑맞을 수 있다.  
**라이프 사이클**: 쿠키도 만료시간을 설정하지만 파일로 저장하고 옵션이 있기에 설정에 따라 브라우저 종료 후에도 쿠키를 유지하거나 정보를 남길 수 있다. 만료시간을 매우 길게 잡는다면 사용자가 쿠키를 인위적으로 삭제하기 전까지도 이론상 존재할 수 있다. 하지만 세션은 브라우저 종료시 무조건 사라진다. 
**속도**: 쿠키는 로컬에서 정보를 관리해서 요청을 보낼 때 속도가 빠르고 세션은 서버에서 한번 정보를 가져와 처리를 해야하기에 더 느리다. 

_세션은 서버의 자원을 사용해 계속 사용하면 서버의 메모리가 감당할 수 없을 정도로 늘어나고 속도가 느려질 위험이 있다_. 

* 캐시는 이미지, css, js파일 등을 브라우저 혹은 서버 앞 단에 저장해 사용하는 것으로 한번 저장되면 브라우저를 참고하기에 서버에서 변경되어도 사용자는 변경된 것을 못 볼 수도 있다. 쿠키와 세션과는 확연하게 저장 위치, 보안과 라이프 사이클에서 다르다. 

### Conclusion
쿠키와 세션은 고전적으로 로그인에 많이 사용하는 기술로 서비스를 더욱 효율적으로 사용하는데 유용하다. 하지만 쿠키는 보안의 문제가 있고 또 세션은 사용자의 숫자가 지속적으로 늘어나는 만큼 서버 메모리를 차지해 과부하를 일으킬 위험이 있어 또 이러한 문제들을 보완하기 위해 토큰 기반의 인증방식을 더 자주사용한다. 보통 토큰과 쿠키, 혹은 토큰과 세션을 잘 혼합해 사용한다. 

**출처**
https://jeong-pro.tistory.com/80
https://interconnection.tistory.com/74
https://cjh5414.github.io/cookie-and-session/
https://wooooooak.github.io/web/2018/10/27/%EC%BF%A0%ED%82%A4vs%EC%84%B8%EC%85%98/
